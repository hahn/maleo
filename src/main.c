/* main.c generated by valac 0.28.1, the Vala compiler
 * generated from main.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <config.h>
#include <gtk/gtk.h>
#include <stdio.h>


#define TYPE_CONFIG_XML (config_xml_get_type ())
#define CONFIG_XML(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CONFIG_XML, ConfigXML))
#define CONFIG_XML_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CONFIG_XML, ConfigXMLClass))
#define IS_CONFIG_XML(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CONFIG_XML))
#define IS_CONFIG_XML_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CONFIG_XML))
#define CONFIG_XML_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CONFIG_XML, ConfigXMLClass))

typedef struct _ConfigXML ConfigXML;
typedef struct _ConfigXMLClass ConfigXMLClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _config_xml_unref0(var) ((var == NULL) ? NULL : (var = (config_xml_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_APP_WINDOW (app_window_get_type ())
#define APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP_WINDOW, AppWindow))
#define APP_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP_WINDOW, AppWindowClass))
#define IS_APP_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP_WINDOW))
#define IS_APP_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP_WINDOW))
#define APP_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP_WINDOW, AppWindowClass))

typedef struct _AppWindow AppWindow;
typedef struct _AppWindowClass AppWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))



gint _vala_main (gchar** args, int args_length1);
gpointer config_xml_ref (gpointer instance);
void config_xml_unref (gpointer instance);
GParamSpec* param_spec_config_xml (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_config_xml (GValue* value, gpointer v_object);
void value_take_config_xml (GValue* value, gpointer v_object);
gpointer value_get_config_xml (const GValue* value);
GType config_xml_get_type (void) G_GNUC_CONST;
ConfigXML* config_xml_new (const gchar* path);
ConfigXML* config_xml_construct (GType object_type, const gchar* path);
const gchar* config_xml_get_nodejs_app (ConfigXML* self);
const gchar* config_xml_get_directory (ConfigXML* self);
GType app_window_get_type (void) G_GNUC_CONST;
AppWindow* app_window_new (ConfigXML* config);
AppWindow* app_window_construct (GType object_type, ConfigXML* config);
gint config_xml_get_width (ConfigXML* self);
gint config_xml_get_height (ConfigXML* self);
const gchar* config_xml_get_title (ConfigXML* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	GPid nodejs_pid = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	GError * _inner_error_ = NULL;
	nodejs_pid = (GPid) 0;
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	gtk_init (&args_length1, &args);
	_tmp0_ = args;
	_tmp0__length1 = args_length1;
	if (_tmp0__length1 > 1) {
		ConfigXML* c = NULL;
		gchar** _tmp1_ = NULL;
		gint _tmp1__length1 = 0;
		const gchar* _tmp2_ = NULL;
		ConfigXML* _tmp3_ = NULL;
		ConfigXML* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		AppWindow* w = NULL;
		ConfigXML* _tmp28_ = NULL;
		AppWindow* _tmp29_ = NULL;
		ConfigXML* _tmp30_ = NULL;
		gint _tmp31_ = 0;
		gint _tmp32_ = 0;
		ConfigXML* _tmp37_ = NULL;
		gint _tmp38_ = 0;
		gint _tmp39_ = 0;
		AppWindow* _tmp44_ = NULL;
		ConfigXML* _tmp45_ = NULL;
		const gchar* _tmp46_ = NULL;
		const gchar* _tmp47_ = NULL;
		gchar* _tmp48_ = NULL;
		gchar* _tmp49_ = NULL;
		AppWindow* _tmp50_ = NULL;
		_tmp1_ = args;
		_tmp1__length1 = args_length1;
		_tmp2_ = _tmp1_[1];
		_tmp3_ = config_xml_new (_tmp2_);
		c = _tmp3_;
		_tmp4_ = c;
		_tmp5_ = config_xml_get_nodejs_app (_tmp4_);
		_tmp6_ = _tmp5_;
		if (_tmp6_ != NULL) {
			gchar* node = NULL;
			gchar* _tmp7_ = NULL;
			const gchar* _tmp8_ = NULL;
			_tmp7_ = g_find_program_in_path ("nodejs");
			node = _tmp7_;
			_tmp8_ = node;
			if (_tmp8_ != NULL) {
				gchar** argv = NULL;
				const gchar* _tmp9_ = NULL;
				gchar* _tmp10_ = NULL;
				ConfigXML* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				gchar** _tmp15_ = NULL;
				gint argv_length1 = 0;
				gint _argv_size_ = 0;
				_tmp9_ = node;
				_tmp10_ = g_strdup (_tmp9_);
				_tmp11_ = c;
				_tmp12_ = config_xml_get_nodejs_app (_tmp11_);
				_tmp13_ = _tmp12_;
				_tmp14_ = g_strdup (_tmp13_);
				_tmp15_ = g_new0 (gchar*, 2 + 1);
				_tmp15_[0] = _tmp10_;
				_tmp15_[1] = _tmp14_;
				argv = _tmp15_;
				argv_length1 = 2;
				_argv_size_ = argv_length1;
				{
					ConfigXML* _tmp16_ = NULL;
					const gchar* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					gchar** _tmp19_ = NULL;
					gint _tmp19__length1 = 0;
					GPid _tmp20_ = 0;
					_tmp16_ = c;
					_tmp17_ = config_xml_get_directory (_tmp16_);
					_tmp18_ = _tmp17_;
					_tmp19_ = argv;
					_tmp19__length1 = argv_length1;
					g_spawn_async (_tmp18_, _tmp19_, NULL, 0, NULL, NULL, &_tmp20_, &_inner_error_);
					nodejs_pid = _tmp20_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_SPAWN_ERROR) {
							goto __catch0_g_spawn_error;
						}
						argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
						_g_free0 (node);
						_config_xml_unref0 (c);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return 0;
					}
				}
				goto __finally0;
				__catch0_g_spawn_error:
				{
					GError* e = NULL;
					FILE* _tmp21_ = NULL;
					GError* _tmp22_ = NULL;
					const gchar* _tmp23_ = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_tmp21_ = stderr;
					_tmp22_ = e;
					_tmp23_ = _tmp22_->message;
					fprintf (_tmp21_, "Unable to execute node application: %s\n", _tmp23_);
					result = -1;
					_g_error_free0 (e);
					argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (node);
					_config_xml_unref0 (c);
					return result;
				}
				__finally0:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (node);
					_config_xml_unref0 (c);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return 0;
				}
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			} else {
				gchar* path = NULL;
				const gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				FILE* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				_tmp24_ = g_getenv ("PATH");
				_tmp25_ = g_strdup (_tmp24_);
				path = _tmp25_;
				_tmp26_ = stderr;
				_tmp27_ = path;
				fprintf (_tmp26_, "Unable to find nodejs in your path: %s.\n", _tmp27_);
				_g_free0 (path);
			}
			_g_free0 (node);
		}
		_tmp28_ = c;
		_tmp29_ = app_window_new (_tmp28_);
		g_object_ref_sink (_tmp29_);
		w = _tmp29_;
		_tmp30_ = c;
		_tmp31_ = config_xml_get_width (_tmp30_);
		_tmp32_ = _tmp31_;
		if (_tmp32_ != (-1)) {
			AppWindow* _tmp33_ = NULL;
			ConfigXML* _tmp34_ = NULL;
			gint _tmp35_ = 0;
			gint _tmp36_ = 0;
			_tmp33_ = w;
			_tmp34_ = c;
			_tmp35_ = config_xml_get_width (_tmp34_);
			_tmp36_ = _tmp35_;
			g_object_set ((GtkWindow*) _tmp33_, "default-width", _tmp36_, NULL);
		}
		_tmp37_ = c;
		_tmp38_ = config_xml_get_height (_tmp37_);
		_tmp39_ = _tmp38_;
		if (_tmp39_ != (-1)) {
			AppWindow* _tmp40_ = NULL;
			ConfigXML* _tmp41_ = NULL;
			gint _tmp42_ = 0;
			gint _tmp43_ = 0;
			_tmp40_ = w;
			_tmp41_ = c;
			_tmp42_ = config_xml_get_height (_tmp41_);
			_tmp43_ = _tmp42_;
			g_object_set ((GtkWindow*) _tmp40_, "default-height", _tmp43_, NULL);
		}
		_tmp44_ = w;
		_tmp45_ = c;
		_tmp46_ = config_xml_get_title (_tmp45_);
		_tmp47_ = _tmp46_;
		_tmp48_ = string_strip (_tmp47_);
		_tmp49_ = _tmp48_;
		gtk_window_set_title ((GtkWindow*) _tmp44_, _tmp49_);
		_g_free0 (_tmp49_);
		_tmp50_ = w;
		gtk_widget_show_all ((GtkWidget*) _tmp50_);
		_g_object_unref0 (w);
		_config_xml_unref0 (c);
	}
	gtk_main ();
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



